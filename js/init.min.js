// # Some of application.js, bpm-delay.js, knob.js,
// waveshaper.js and wavetable.js:
//
// Copyright 2012, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// # Plus fft.js:
//
// Copyright (c) 2010 Corban Brook, released under the MIT license
// Fourier Transform Module used by DFT, FFT, RFT
// Slightly modified for packed DC/nyquist...

function getElementCoordinates(element, event) {
    var c = getAbsolutePosition(element);
    c.x = event.x - c.x;
    c.y = event.y - c.y;

    var position = c;

    // This isn't the best, should abstract better.
    if (isNaN(c.y)) {
        var eventInfo = {event:event, element:element};
        position = getRelativeCoordinates(eventInfo);
    }

    return position;
}

function getAbsolutePosition(element) {
  var r = { x: element.offsetLeft, y: element.offsetTop };
  if (element.offsetParent) {
    var tmp = getAbsolutePosition(element.offsetParent);
    r.x += tmp.x;
    r.y += tmp.y;
  }
  return r;
};


function getRelativeCoordinates(eventInfo, opt_reference) {
    var x, y;
    var event = eventInfo.event;
    var element = eventInfo.element;
    var reference = opt_reference || eventInfo.element;
    if (!window.opera && typeof event.offsetX != 'undefined') {
      // Use offset coordinates and find common offsetParent
      var pos = { x: event.offsetX, y: event.offsetY };
      // Send the coordinates upwards through the offsetParent chain.
      var e = element;
      while (e) {
        e.mouseX = pos.x;
        e.mouseY = pos.y;
        pos.x += e.offsetLeft;
        pos.y += e.offsetTop;
        e = e.offsetParent;
      }
      // Look for the coordinates starting from the reference element.
      var e = reference;
      var offset = { x: 0, y: 0 }
      while (e) {
        if (typeof e.mouseX != 'undefined') {
          x = e.mouseX - offset.x;
          y = e.mouseY - offset.y;
          break;
        }
        offset.x += e.offsetLeft;
        offset.y += e.offsetTop;
        e = e.offsetParent;
      }
      // Reset stored coordinates
      e = element;
      while (e) {
        e.mouseX = undefined;
        e.mouseY = undefined;
        e = e.offsetParent;
      }
    } else {
      // Use absolute coordinates
      var pos = getAbsolutePosition(reference);
      x = event.pageX - pos.x;
      y = event.pageY - pos.y;
    }
    // Subtract distance to middle
    return { x: x, y: y };
  };




  function addSlider(name) {
    var controls = document.getElementById("controls");

    var divName = name + "Slider";


    var sliderText = '<div style="width:500px; height:20px;"> <input id="' + divName + '" '
     + 'type="range" min="0" max="1" step="0.01" value="0" style="height: 20px; width: 450px;"> <div id="'
     + name
     + '-value" style="position:relative; left:30em; top:-18px;">'
     + name
     + '</div> </div> <br>  ';

    controls.innerHTML = controls.innerHTML + sliderText;
  }

  function configureSlider(name, value, min, max, handler) {
      // var controls = document.getElementById("controls");
      //

      var divName = name + "Slider";

      var slider = document.getElementById(divName);

      slider.min = min;
      slider.max = max;
      slider.value = value;
      slider.onchange = function() { handler(0, this); };
  }

  function addSliderOld(name) {
    var controls = document.getElementById("controls");

    var divName = name + "Slider";

    var sliderText = '<div id="'
     + divName
     + '" style="width:500px;"> <div id="'
     + name
     + '-value" style="position:relative; left:30em;">'
     + name
     + '</div> </div> <br>  ';

    controls.innerHTML = controls.innerHTML + sliderText;
  }

  function configureSliderOld(name, value, min, max, handler) {
   var controls = document.getElementById("controls");

   var divName = name + "Slider";

   // var slider = document.getElementById(divName);
   var slider = $("#" + divName);
   // var slider = document.getElementById("#" + divName);
   slider.slider({ min: min } );
   slider.slider('option', 'max', max);
   slider.slider('option', 'step', 0.001);
   slider.slider('value', value);

   slider.bind('slide', handler);
  }


/* **********************************************
     Begin fft.js
********************************************** */

// Copyright (c) 2010 Corban Brook, released under the MIT license
// Fourier Transform Module used by DFT, FFT, RFT
// Slightly modified for packed DC/nyquist...

function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

/**
 * Performs a forward tranform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function(buffer) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length)  { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  // Pack nyquist component.
  imag[0] = real[bufferSize / 2];
};

FFT.prototype.inverse = function(real, imag) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      spectrum        = this.spectrum;

      real = real || this.real;
      imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

      // Unpack and create mirror image.
      // This isn't that efficient, but let's us avoid having to deal with the mirror image part
      // when processing.
      var n = bufferSize;
      var nyquist = imag[0];
      imag[0] = 0;
      real[n / 2] = nyquist;
      imag[n / 2] = 0;

      // Mirror image complex conjugate.
      for (i = 1 + n / 2; i < n; i++) {
          real[i] = real[n - i];
          imag[i] = -imag[n - i];
      }

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);





  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }

  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};


/* **********************************************
     Begin bpm-delay.js
********************************************** */

// Copyright 2011, Google Inc.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var times =
[
	1/8.,			// 32nd note
	(1/4.) * 2/3.,	// 16th note triplet
	(1/8.) * 3/2.,	// dotted 32nd note
	1/4.,			// 16th note
	(1/2.) * 2/3.,	// 8th note triplet
	(1/4.) * 3/2.,	// dotted 16th note
	1/2.,			// 8th note
	1   * 2/3.,		// quarter note triplet
	(1/2.) * 3/2.,	// dotted eighth note
	1,				// quarter note
	2   * 2/3.,		// half note triplet
	1   * 3/2.,		// dotted quarter note
	2				// half note
];

function BpmDelay(context) {
    this.delay = context.createDelayNode();
    this.context = context;
    this.tempo = 120;
    this.noteDivision = times[6];
    
    this.updateDelayTime();
}

BpmDelay.prototype.setTempo = function(tempo) {
    this.tempo = tempo;
    this.updateDelayTime();
}

BpmDelay.prototype.setDelayValue = function(v) {
    var i = 6;
    
    if (v == "32nd note") {
        i = 0;
    } else if (v == "16th note triplet") {
        i = 1;
    } else if (v == "dotted 32nd note") {
        i = 2;
    } else if (v == "16th note") {
        i = 3;
    } else if (v == "8th note triplet") {
        i = 4;
    } else if (v == "dotted 16th note") {
        i = 5;
    } else if (v == "8th note") {
        i = 6;
    } else if (v == "quarter note triplet") {
        i = 7;
    } else if (v == "dotted eighth note") {
        i = 8;
    } else if (v == "quarter note") {
        i = 9;
    }  else {
        alert("bad BPM index");
    }
    
    this.setDelayIndex(i);
}

BpmDelay.prototype.setDelayIndex = function(i) {
    this.noteDivision = times[i];
    this.updateDelayTime();
}

BpmDelay.prototype.updateDelayTime = function() {
    var delayTime = 0.37299 / 44100.0 + 60 * this.noteDivision / this.tempo;
    this.delay.delayTime.value = delayTime;
}


/* **********************************************
     Begin waveshaper.js
********************************************** */

// Copyright 2011, Google Inc.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var threshold = -24; // dB
var headroom = 21; // dB

function e4(x, k)
{
    return 1.0 - Math.exp(-k * x);
}

function dBToLinear(db) {
    return Math.pow(10.0, 0.05 * db);
}

function shape(x) {
    var linearThreshold = dBToLinear(threshold);
    var linearHeadroom = dBToLinear(headroom);
    
    var maximum = 1.05 * linearHeadroom * linearThreshold;
    var kk = (maximum - linearThreshold);
    
    var sign = x < 0 ? -1 : +1;
    var absx = Math.abs(x);
    
    var shapedInput = absx < linearThreshold ? absx : linearThreshold + kk * e4(absx - linearThreshold, 1.0 / kk);
    shapedInput *= sign;
    
    return shapedInput;
}

function generateColortouchCurve(curve) {
    var n = 65536;
    var n2 = n / 2;
    
    for (var i = 0; i < n2; ++i) {
        x = i / n2;
        x = shape(x);
        
        curve[n2 + i] = x;
        curve[n2 - i - 1] = -x;
    }
    
    return curve;
}

function WaveShaper(context) {
    this.context = context;
    var waveshaper = context.createWaveShaper();
    var preGain = context.createGainNode();
    var postGain = context.createGainNode();
    preGain.connect(waveshaper);
    waveshaper.connect(postGain);
    this.input = preGain;
    this.output = postGain;
    
    var curve = new Float32Array(65536); // FIXME: share across instances
    generateColortouchCurve(curve);
    waveshaper.curve = curve;
}

WaveShaper.prototype.setDrive = function(drive) {
    this.input.gain.value = drive;
    var postDrive = Math.pow(1 / drive, 0.6);
    this.output.gain.value = postDrive;
}


/* **********************************************
     Begin wavetable.js
********************************************** */

// Copyright 2011, Google Inc.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var kDefaultNumberOfResampleRanges = 11;

function WaveTable(name, context) {
    this.name = name;
    this.context = context;
    this.sampleRate = context.sampleRate;
    this.url = "wave-tables/" + this.name;
    this.waveTableSize = 4096; // hard-coded for now
    this.buffer = 0;
    this.numberOfResampleRanges = kDefaultNumberOfResampleRanges;
}

WaveTable.prototype.getWaveDataForPitch = function(pitchFrequency) {
    var nyquist = 0.5 * this.sampleRate;
    var lowestNumPartials = this.getNumberOfPartialsForRange(0);
    var lowestFundamental = nyquist / lowestNumPartials;

    // Find out pitch range
    var ratio = pitchFrequency / lowestFundamental;
    var pitchRange = ratio == 0.0 ? 0 : Math.floor(Math.log(ratio) / Math.LN2);

    if (pitchRange < 0)
        pitchRange = 0;

    // Too bad, we'll alias if pitch is greater than around 5KHz :)
    if (pitchRange >= this.numberOfResampleRanges)
        pitchRange = this.numberOfResampleRanges - 1;

    return this.buffers[pitchRange];
}

WaveTable.prototype.getNumberOfPartialsForRange = function(j) {
	// goes from 1024 -> 4 @ 44.1KHz (and do same for 48KHz)
	// goes from 2048 -> 8 @ 96KHz
	var npartials = Math.pow(2, 1 + this.numberOfResampleRanges - j);
	if (this.getSampleRate() > 48000.0)
	    npartials *= 2;  // high sample rate allows more harmonics at given fundamental
	
	return npartials;
}

WaveTable.prototype.getWaveTableSize = function() {
    return this.waveTableSize;
}

WaveTable.prototype.getSampleRate = function() {
    return this.sampleRate;
}

WaveTable.prototype.getRateScale = function() {
    return this.getWaveTableSize() / this.getSampleRate();
}

WaveTable.prototype.getNumberOfResampleRanges = function() {
    this.numberOfResampleRanges;
}

WaveTable.prototype.getName = function() {
    return this.name;
}

WaveTable.prototype.load = function(callback) {
    var request = new XMLHttpRequest();
    request.open("GET", this.url, true);
    var wave = this;
    
    request.onload = function() {
        // Get the frequency-domain waveform data.
        var f = eval('(' + request.responseText + ')');

        // Copy into more efficient Float32Arrays.
        var n = f.real.length;
        frequencyData = { "real": new Float32Array(n), "imag": new Float32Array(n) };
        wave.frequencyData = frequencyData;
        for (var i = 0; i < n; ++i) {
            frequencyData.real[i] = f.real[i];
            frequencyData.imag[i] = f.imag[i];
        }
        
        wave.createBuffers();
        if (callback)
            callback(wave);
    };

    request.onerror = function() {
        alert("error loading: " + wave.url);
    };

    request.send();
}

WaveTable.prototype.print = function() {
    var f = this.frequencyData;

    var info = document.getElementById("info");
    
    var s = "";
    for (var i = 0; i < 2048; ++i) {
        s += "{" + f.real[i] + ", " + f.imag[i] + "}, <br>";
    }

    info.innerHTML = s;
}

WaveTable.prototype.printBuffer = function(buffer) {
    var info = document.getElementById("info");
    
    var s = "";
    for (var i = 0; i < 4096; ++i) {
        s += buffer[i] + "<br>";
    }

    info.innerHTML = s;
}

// WaveTable.prototype.createBuffers = function() {
//     var f = this.frequencyData;
//     
//     var n = 4096;
//     
//     var fft = new FFT(n, 44100);
//         
//     // Copy from loaded frequency data and scale.
//     for (var i = 0; i < n / 2; ++i) {
//         fft.real[i] = 4096 * f.real[i];
//         fft.imag[i] = 4096 * f.imag[i];
//     }
// 
//     // Now do inverse FFT
//     this.data = fft.inverse();
//     var data = this.data;
//     
//     this.buffer = context.createBuffer(1, data.length, 44100);
//     
//     // Copy data to the buffer.
//     var p = this.buffer.getChannelData(0);
//     for (var i = 0; i < data.length; ++i) {
//         p[i] = data[i];
//     }
// }

// Convert into time-domain wave tables.
// We actually create several of them for non-aliasing playback at different playback rates.
WaveTable.prototype.createBuffers = function() {
	// resample ranges
	//
	// let's divide up versions of our waves based on the maximum fundamental frequency we're
	// resampling at.  Let's use fundamental frequencies based on dividing Nyquist by powers of two.
	// For example for 44.1KHz sample-rate we have:
	//
	//		ranges
	//		----------------------------------
	//		21Hz, 43Hz, 86Hz, 172Hz, 344Hz, 689Hz, 1378Hz, 2756Hz, 5512Hz, 11025Hz, 22050Hz               <-- 44.1KHz
	//		23Hz, 47Hz, 94Hz, 187Hz, 375Hz, 750Hz, 1500Hz, 3000Hz, 6000Hz, 12000Hz, 24000Hz, 48000Hz      <-- 96KHz
	//
	// and number of partials:
	//
	//      1024, 512,  256,  128,    64,    32,    16,     8,       4,      2,       1
	//		2048, 1024, 512,  256,   128,    64,    32,    16,       8,      4,       2,     1
	//
	// But it's probably OK if we skip the very highest fundamental frequencies and only
	// go up to 5512Hz, so we have a total of 9 resample ranges
	//
	//      0      1     2     3      4       5     6       7        8

	// The FFT size needs to be at least 2048 @ 44.1KHz and 4096 @ 96KHz
	//
	// So let's try to use FFT size of 4096 all the time and pull out the harmonics we want
	//
	
	this.buffers = new Array();
	
	var finalScale = 1.0;

	for (var j = 0; j < this.numberOfResampleRanges; ++j) {
        var n = this.waveTableSize;
        var frame = new FFT(n, this.sampleRate);

        // Copy from loaded frequency data and scale.
        var f = this.frequencyData;
        var scale = n;
        for (var i = 0; i < n / 2; ++i) {
            frame.real[i] = scale * f.real[i];
            frame.imag[i] = scale * f.imag[i];
        }

		var realP = frame.real;
		var imagP = frame.imag;

		// Find the starting bin where we should start clearing out
		// (we need to clear out the highest frequencies to band-limit the waveform)
		var fftSize = n;
		var halfSize = fftSize / 2;

		var npartials = this.getNumberOfPartialsForRange(j);

		// Now, go through and cull out the aliasing harmonics...
		for (var i = npartials + 1; i < halfSize; i++) {
			realP[i] = 0.0;
			imagP[i] = 0.0;
		}
		// Clear packed-nyquist if necessary
		if (npartials < halfSize)
			imagP[0] = 0.0;

		// Clear any DC-offset
		realP[0] = 0.0;

        // For the first resample range, find power and compute scale.
        if (j == 0) {
            var power = 0;
            for (var i = 1; i < halfSize; ++i) {
                x = realP[i];
                y = imagP[i];
                power += x * x + y * y;
            }
            power = Math.sqrt(power) / fftSize;
            
            finalScale = 0.5 / power;

            // window.console.log("power = " + power);
        }

		// Great, now do inverse FFT into our wavetable...
        var data = frame.inverse();

        // Create mono AudioBuffer.
        var buffer = this.context.createBuffer(1, data.length, this.sampleRate);
        
        // Copy data to the buffer.
        var p = buffer.getChannelData(0);
        for (var i = 0; i < data.length; ++i) {
            p[i] = finalScale * data[i];
        }

		this.buffers[j] = buffer;
	}
}

WaveTable.prototype.displayWaveData = function() {
    var data = this.data;
    var n = data.length;

    var s = "";
    for (var i = 0; i < n; ++i) {
        s += data[i].toFixed(3) + "<br> ";
    }
    
    var info = document.getElementById("info");

    info.innerHTML = s;
}


/* **********************************************
     Begin knob.js
********************************************** */

// Copyright 2011, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var currentView = 0; // FIXME: global...

var UNITS = {
    "hertz": 0,
    "cents": 1,
    "decibels": 2,
    "seconds": 3,
    "indexed": 4,
    "percent": 5,
    "bpm": 6,
    "generic": 7,
};

function KnobView(name, value, minValue, maxValue, units, precision, useLogScale, onchange) {
    this.name = name;
    this.value = value;
    this.minValue = minValue;
    this.maxValue = maxValue;
    this.units = units;
    this.useLogScale = useLogScale;
    this.precision = precision;

    this.preValue = this.valueToPre(value);

    this.onchange = onchange;

    this.backgroundColor = "rgb(60,40,40)";
    this.knobColor = "rgb(200,150,150)";
    this.knobOutlineColor = "rgb(255,255,255)";
    this.valueIndicatorColor = "rgb(80,100,100)";
    this.textColor = "rgb(255,255,255)";
}

KnobView.prototype.attach = function() {
    // Create the canvas
    var canvas = document.getElementById(this.name);
    this.canvas = canvas;

    var ctx = canvas.getContext('2d');
    this.ctx = ctx;

    this.width = canvas.width;
    this.height = canvas.height;

    var view = this;
    canvas.addEventListener("mousedown",
        function(event) {
            // var eventInfo = {event: event, element:view.canvas};
            // var position = getRelativeCoordinates(eventInfo);

            var position = getElementCoordinates(view, event);

            currentView = view;
            view.isDragging = true;
            view.startPosition = position;
            view.startPreValue = view.valueToPre(view.value);

            view.mouseDown(position);
        },
        true
    );

    // Note: document handles mouseup and mousemove events.
    document.addEventListener("mousemove",
        function(event) {
            if (currentView && currentView == view) {
                var position = getElementCoordinates(currentView.canvas, event);

                // var c = getAbsolutePosition(currentView.canvas);
                // c.x = event.x - c.x;
                // c.y = event.y - c.y;
                //
                // var position = c;
                //
                // // This isn't the best, should abstract better.
                // if (isNaN(c.y)) {
                //     var eventInfo = {event: event, element:currentView.canvas};
                //     position = getRelativeCoordinates(eventInfo);
                // }

                currentView.mouseMove(position);
            }
        },
        true
    );

    document.addEventListener("mouseup",
        function(event) {
            if (currentView && currentView == view) {
                view.isDragging = false;
                // var eventInfo = {event: event, element:currentView.canvas};
                // var position = getRelativeCoordinates(eventInfo);

                var position = getElementCoordinates(currentView.canvas, event);

                currentView.mouseUp(position);
                currentView = 0;
            }
        },
        true
    );

    this.draw();
}

KnobView.prototype.preToValue = function(preValue) {
    if (this.useLogScale) {
        // Interpolate in log space.
        var v1 = Math.log(this.minValue);
        var v2 = Math.log(this.maxValue);
        var v = v1 + preValue * (v2 - v1);
        return Math.exp(v);
    } else {
        return this.minValue + preValue * (this.maxValue - this.minValue);
    }
}

KnobView.prototype.valueToPre = function(value) {
    if (this.useLogScale) {
        var v1 = Math.log(this.minValue);
        var v2 = Math.log(this.maxValue);
        var v = Math.log(value);
        return (v - v1) / (v2 - v1);
    } else {
        return (value - this.minValue) / (this.maxValue - this.minValue);
    }
}


KnobView.prototype.draw = function() {
    var ctx = this.ctx;
    var width = this.width;
    var height = this.height;

    // Draw background.
    ctx.fillStyle = this.backgroundColor;
    ctx.fillRect(0,0, width, height);

    // Draw body of knob.
    ctx.fillStyle = this.knobColor;
    ctx.beginPath();
    var knobRadius = 0.7 * height / 2;
    var knobOffset = 10;
    ctx.arc(knobRadius + knobOffset , height / 2 , knobRadius, 0, Math.PI * 2, true);
    ctx.fill();

    // Draw body of knob.
    ctx.strokeStyle = this.knobOutlineColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(knobRadius + knobOffset , height / 2 , knobRadius, 0, Math.PI * 2, true);
    ctx.stroke();

    // Draw value indicator.
    ctx.strokeStyle = this.valueIndicatorColor;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.beginPath();

    var startAngle = (2 - 0.25)*Math.PI;
    var endAngle = 0.25*Math.PI;
    var angle = -0.5*Math.PI + startAngle * (1 - this.preValue) + endAngle * this.preValue;

    var knobx = 0.8 * knobRadius * Math.cos(angle);
    var knoby = 0.8 * knobRadius * Math.sin(angle);
    ctx.moveTo(knobRadius + knobOffset, height / 2);
    ctx.lineTo(knobx + knobRadius + knobOffset, -knoby + height / 2);
    ctx.stroke();

    // Draw name.
    ctx.textAlign = "left";
    ctx.fillStyle = this.textColor;
    ctx.lineWidth = 1;
    ctx.font = "12pt Helvetica";
    var textVerticalPosition = height - 6;
    // canvasContext.strokeText(this.value.toFixed(0) + " dBFS", 25, y - 5);
    var textPosition = 2*knobRadius + knobOffset + 12;
    ctx.fillText(this.name, textPosition, textVerticalPosition);

    // Draw value.
    var valuePosition = width - 30; //2*knobRadius + knobOffset + 300;
    var s = this.value.toFixed(this.precision);

    switch (this.units) {
        case UNITS.hertz:
        s += " Hz"; break;
        case UNITS.cents:
        s += " cents"; break;
        case UNITS.decibels:
        s += " dB"; break;
        case UNITS.seconds:
        s += " sec"; break;
        case UNITS.percent:
        s += "%"; break;
        case UNITS.bpm:
        s += " bpm"; break;
        case UNITS.generic:
    }

    ctx.textAlign = "right";
    ctx.fillText(s, valuePosition, textVerticalPosition);

}

KnobView.prototype.mouseDown = function(position) {
}

KnobView.prototype.mouseMove = function(position) {
    if (this.isDragging) {
        this.mouseDrag(position);
    }
}

KnobView.prototype.mouseDrag = function(position) {
    var deltay = position.y - this.startPosition.y;
    var range = 200;

    // Offset from original value
    var k = this.startPreValue + -deltay / range;
    if (k < 0) k = 0;
    if (k > 1) k = 1;

    this.preValue = k;
    this.value = this.preToValue(k);

    if (this.units == UNITS.indexed)
        this.value = Math.floor(this.value);

    this.onchange(this.value);
    this.draw();
}

KnobView.prototype.mouseUp = function(position) {
}

function installViews(views, parentDiv) {
    var ss = "";
    for (var i = 0; i < views.length; ++i) {
        var view = views[i];

        var s = "<canvas id=\"";
        s += view.name; // FIXME: namespace...
        s += "\" width=\"260\" height=\"24\"> </canvas>";

        ss += s;
    }

    // alert("ss = " + ss);

    parentDiv.innerHTML = ss;

    for (var i = 0; i < views.length; ++i) {
        var view = views[i];
        view.attach();
    }
}


/* **********************************************
     Begin zepto-1.0.rc.js
********************************************** */

/* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */
;(function(undefined){
  if (String.prototype.trim === undefined) // fix for iOS 3.2
    String.prototype.trim = function(){ return this.replace(/^\s+/, '').replace(/\s+$/, '') }

  // For iOS 3.x
  // from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce
  if (Array.prototype.reduce === undefined)
    Array.prototype.reduce = function(fun){
      if(this === void 0 || this === null) throw new TypeError()
      var t = Object(this), len = t.length >>> 0, k = 0, accumulator
      if(typeof fun != 'function') throw new TypeError()
      if(len == 0 && arguments.length == 1) throw new TypeError()

      if(arguments.length >= 2)
       accumulator = arguments[1]
      else
        do{
          if(k in t){
            accumulator = t[k++]
            break
          }
          if(++k >= len) throw new TypeError()
        } while (true)

      while (k < len){
        if(k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t)
        k++
      }
      return accumulator
    }

})()
var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    getComputedStyle = document.defaultView.getComputedStyle,
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,

    // Used by `$.zepto.init` to wrap elements, text/comment nodes, document,
    // and document fragment node types.
    elementTypes = [1, 3, 8, 9, 11],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    readyRE = /complete|loaded|interactive/,
    classSelectorRE = /^\.([\w-]+)$/,
    idSelectorRE = /^#([\w-]+)$/,
    tagSelectorRE = /^[\w-]+$/,
    toString = ({}).toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div')

  zepto.matches = function(element, selector) {
    if (!element || element.nodeType !== 1) return false
    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector ||
                          element.oMatchesSelector || element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent
    if (temp) (parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp && tempParent.removeChild(element)
    return match
  }

  function isFunction(value) { return toString.call(value) == "[object Function]" }
  function isObject(value) { return value instanceof Object }
  function isPlainObject(value) {
    var key, ctor
    if (toString.call(value) !== "[object Object]") return false
    ctor = (isFunction(value.constructor) && value.constructor.prototype)
    if (!ctor || !hasOwnProperty.call(ctor, 'isPrototypeOf')) return false
    for (key in value);
    return key === undefined || hasOwnProperty.call(value, key)
  }
  function isArray(value) { return value instanceof Array }
  function likeArray(obj) { return typeof obj.length == 'number' }

  function compact(array) { return array.filter(function(item){ return item !== undefined && item !== null }) }
  function flatten(array) { return array.length > 0 ? [].concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return array.filter(function(item, idx){ return array.indexOf(item) == idx }) }

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName)
      document.body.appendChild(element)
      display = getComputedStyle(element, '').getPropertyValue("display")
      element.parentNode.removeChild(element)
      display == "none" && (display = "block")
      elementDisplay[nodeName] = display
    }
    return elementDisplay[nodeName]
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overriden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name) {
    if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
    if (!(name in containers)) name = '*'
    var container = containers[name]
    container.innerHTML = '' + html
    return $.each(slice.call(container.childNodes), function(){
      container.removeChild(this)
    })
  }

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. Note that `__proto__` is not supported on Internet
  // Explorer. This method can be overriden in plugins.
  zepto.Z = function(dom, selector) {
    dom = dom || []
    dom.__proto__ = arguments.callee.prototype
    dom.selector = selector || ''
    return dom
  }

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overriden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  }

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overriden in plugins.
  zepto.init = function(selector, context) {
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z()
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) return $(document).ready(selector)
    // If a Zepto collection is given, juts return it
    else if (zepto.isZ(selector)) return selector
    else {
      var dom
      // normalize array if an array of nodes is given
      if (isArray(selector)) dom = compact(selector)
      // if a JavaScript object is given, return a copy of it
      // this is a somewhat peculiar option, but supported by
      // jQuery so we'll do it, too
      else if (isPlainObject(selector))
        dom = [$.extend({}, selector)], selector = null
      // wrap stuff like `document` or `window`
      else if (elementTypes.indexOf(selector.nodeType) >= 0 || selector === window)
        dom = [selector], selector = null
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
      // create a new Zepto collection from the nodes found
      return zepto.Z(dom, selector)
    }
  }

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, whichs makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    slice.call(arguments, 1).forEach(function(source) {
      for (key in source)
        if (source[key] !== undefined)
          target[key] = source[key]
    })
    return target
  }

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overriden in plugins.
  zepto.qsa = function(element, selector){
    var found
    return (element === document && idSelectorRE.test(selector)) ?
      ( (found = element.getElementById(RegExp.$1)) ? [found] : emptyArray ) :
      (element.nodeType !== 1 && element.nodeType !== 9) ? emptyArray :
      slice.call(
        classSelectorRE.test(selector) ? element.getElementsByClassName(RegExp.$1) :
        tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :
        element.querySelectorAll(selector)
      )
  }

  function filtered(nodes, selector) {
    return selector === undefined ? $(nodes) : $(nodes).filter(selector)
  }

  function funcArg(context, arg, idx, payload) {
   return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  $.isFunction = isFunction
  $.isObject = isObject
  $.isArray = isArray
  $.isPlainObject = isPlainObject

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  }

  $.trim = function(str) { return str.trim() }

  // plugin compatibility
  $.uuid = 0

  $.map = function(elements, callback){
    var value, values = [], i, key
    if (likeArray(elements))
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i)
        if (value != null) values.push(value)
      }
    else
      for (key in elements) {
        value = callback(elements[key], key)
        if (value != null) values.push(value)
      }
    return flatten(values)
  }

  $.each = function(elements, callback){
    var i, key
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        if (callback.call(elements[i], i, elements[i]) === false) return elements
    } else {
      for (key in elements)
        if (callback.call(elements[key], key, elements[key]) === false) return elements
    }

    return elements
  }

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    indexOf: emptyArray.indexOf,
    concat: emptyArray.concat,

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $.map(this, function(el, i){ return fn.call(el, i, el) })
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      if (readyRE.test(document.readyState)) callback($)
      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          this.parentNode.removeChild(this)
      })
    },
    each: function(callback){
      this.forEach(function(el, idx){ callback.call(el, idx, el) })
      return this
    },
    filter: function(selector){
      return $([].filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[]
      if (isFunction(selector) && selector.call !== undefined)
        this.each(function(idx){
          if (!selector.call(this,idx)) nodes.push(this)
        })
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) nodes.push(el)
        })
      }
      return $(nodes)
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0]
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1]
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result
      if (this.length == 1) result = zepto.qsa(this[0], selector)
      else result = this.map(function(){ return zepto.qsa(this, selector) })
      return $(result)
    },
    closest: function(selector, context){
      var node = this[0]
      while (node && !zepto.matches(node, selector))
        node = node !== context && node !== document && node.parentNode
      return $(node)
    },
    parents: function(selector){
      var ancestors = [], nodes = this
      while (nodes.length > 0)
        nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && node !== document && ancestors.indexOf(node) < 0) {
            ancestors.push(node)
            return node
          }
        })
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return slice.call(this.children) }), selector)
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return slice.call(el.parentNode.children).filter(function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = '' })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return this.map(function(){ return this[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = null)
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          this.style.display = defaultDisplay(this.nodeName)
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(newContent){
      return this.each(function(){
        $(this).wrapAll($(newContent)[0].cloneNode(false))
      })
    },
    wrapAll: function(newContent){
      if (this[0]) {
        $(this[0]).before(newContent = $(newContent))
        newContent.append(this)
      }
      return this
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children())
      })
      return this
    },
    clone: function(){
      return $(this.map(function(){ return this.cloneNode(true) }))
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return (setting === undefined ? this.css("display") == "none" : setting) ? this.show() : this.hide()
    },
    prev: function(){ return $(this.pluck('previousElementSibling')) },
    next: function(){ return $(this.pluck('nextElementSibling')) },
    html: function(html){
      return html === undefined ?
        (this.length > 0 ? this[0].innerHTML : null) :
        this.each(function(idx){
          var originHtml = this.innerHTML
          $(this).empty().append( funcArg(this, html, idx, originHtml) )
        })
    },
    text: function(text){
      return text === undefined ?
        (this.length > 0 ? this[0].textContent : null) :
        this.each(function(){ this.textContent = text })
    },
    attr: function(name, value){
      var result
      return (typeof name == 'string' && value === undefined) ?
        (this.length == 0 || this[0].nodeType !== 1 ? undefined :
          (name == 'value' && this[0].nodeName == 'INPUT') ? this.val() :
          (!(result = this[0].getAttribute(name)) && name in this[0]) ? this[0][name] : result
        ) :
        this.each(function(idx){
          if (this.nodeType !== 1) return
          if (isObject(name)) for (key in name) this.setAttribute(key, name[key])
          else this.setAttribute(name, funcArg(this, value, idx, this.getAttribute(name)))
        })
    },
    removeAttr: function(name){
      return this.each(function(){ if (this.nodeType === 1) this.removeAttribute(name) })
    },
    prop: function(name, value){
      return (value === undefined) ?
        (this[0] ? this[0][name] : undefined) :
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name])
        })
    },
    data: function(name, value){
      var data = this.attr('data-' + dasherize(name), value)
      return data !== null ? data : undefined
    },
    val: function(value){
      return (value === undefined) ?
        (this.length > 0 ? this[0].value : undefined) :
        this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value)
        })
    },
    offset: function(){
      if (this.length==0) return null
      var obj = this[0].getBoundingClientRect()
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: obj.width,
        height: obj.height
      }
    },
    css: function(property, value){
      if (value === undefined && typeof property == 'string')
        return (
          this.length == 0
            ? undefined
            : this[0].style[camelize(property)] || getComputedStyle(this[0], '').getPropertyValue(property))

      var css = ''
      for (key in property)
        if(typeof property[key] == 'string' && property[key] == '')
          this.each(function(){ this.style.removeProperty(dasherize(key)) })
        else
          css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'

      if (typeof property == 'string')
        if (value == '')
          this.each(function(){ this.style.removeProperty(dasherize(property)) })
        else
          css = dasherize(property) + ":" + maybeAddPx(property, value)
      
      return this.each(function(){ this.style.cssText += ';' + css })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (this.length < 1) return false
      else return classRE(name).test(this[0].className)
    },
    addClass: function(name){
      return this.each(function(idx){
        classList = []
        var cls = this.className, newName = funcArg(this, name, idx, cls)
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) classList.push(klass)
        }, this)
        classList.length && (this.className += (cls ? " " : "") + classList.join(" "))
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (name === undefined)
          return this.className = ''
        classList = this.className
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ")
        })
        this.className = classList.trim()
      })
    },
    toggleClass: function(name, when){
      return this.each(function(idx){
        var newName = funcArg(this, name, idx, this.className)
        ;(when === undefined ? !$(this).hasClass(newName) : when) ?
          $(this).addClass(newName) : $(this).removeClass(newName)
      })
    }
  }

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    $.fn[dimension] = function(value){
      var offset, Dimension = dimension.replace(/./, function(m){ return m[0].toUpperCase() })
      if (value === undefined) return this[0] == window ? window['inner' + Dimension] :
        this[0] == document ? document.documentElement['offset' + Dimension] :
        (offset = this.offset()) && offset[dimension]
      else return this.each(function(idx){
        var el = $(this)
        el.css(dimension, funcArg(this, value, idx, el[dimension]()))
      })
    }
  })

  function insert(operator, target, node) {
    var parent = (operator % 2) ? target : target.parentNode
    parent ? parent.insertBefore(node,
      !operator ? target.nextSibling :      // after
      operator == 1 ? parent.firstChild :   // prepend
      operator == 2 ? target :              // before
      null) :                               // append
      $(node).remove()
  }

  function traverseNode(node, fun) {
    fun(node)
    for (var key in node.childNodes) traverseNode(node.childNodes[key], fun)
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(key, operator) {
    $.fn[key] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var nodes = $.map(arguments, function(n){ return isObject(n) ? n : zepto.fragment(n) })
      if (nodes.length < 1) return this
      var size = this.length, copyByClone = size > 1, inReverse = operator < 2

      return this.each(function(index, target){
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[inReverse ? nodes.length-i-1 : i]
          traverseNode(node, function(node){
            if (node.nodeName != null && node.nodeName.toUpperCase() === 'SCRIPT' && (!node.type || node.type === 'text/javascript'))
              window['eval'].call(window, node.innerHTML)
          })
          if (copyByClone && index < size - 1) node = node.cloneNode(true)
          insert(operator, target, node)
        }
      })
    }

    $.fn[(operator % 2) ? key+'To' : 'insert'+(operator ? 'Before' : 'After')] = function(html){
      $(html)[key](this)
      return this
    }
  })

  zepto.Z.prototype = $.fn

  // Export internal API functions in the `$.zepto` namespace
  zepto.camelize = camelize
  zepto.uniq = uniq
  $.zepto = zepto

  return $
})()

// If `$` is not yet defined, point it to `Zepto`
window.Zepto = Zepto
'$' in window || (window.$ = Zepto)
;(function($){
  var $$ = $.zepto.qsa, handlers = {}, _zid = 1, specialEvents={}

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event)
    if (event.ns) var matcher = matcherFor(event.ns)
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.')
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eachEvent(events, fn, iterator){
    if ($.isObject(events)) $.each(events, iterator)
    else events.split(/\s/).forEach(function(type){ iterator(type, fn) })
  }

  function add(element, events, fn, selector, getDelegate, capture){
    capture = !!capture
    var id = zid(element), set = (handlers[id] || (handlers[id] = []))
    eachEvent(events, fn, function(event, fn){
      var delegate = getDelegate && getDelegate(fn, event),
        callback = delegate || fn
      var proxyfn = function (event) {
        var result = callback.apply(element, [event].concat(event.data))
        if (result === false) event.preventDefault()
        return result
      }
      var handler = $.extend(parse(event), {fn: fn, proxy: proxyfn, sel: selector, del: delegate, i: set.length})
      set.push(handler)
      element.addEventListener(handler.e, proxyfn, capture)
    })
  }
  function remove(element, events, fn, selector){
    var id = zid(element)
    eachEvent(events || '', fn, function(event, fn){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i]
        element.removeEventListener(handler.e, handler.proxy, false)
      })
    })
  }

  $.event = { add: add, remove: remove }

  $.proxy = function(fn, context) {
    if ($.isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, arguments) }
      proxyFn._zid = zid(fn)
      return proxyFn
    } else if (typeof context == 'string') {
      return $.proxy(fn[context], fn)
    } else {
      throw new TypeError("expected function")
    }
  }

  $.fn.bind = function(event, callback){
    return this.each(function(){
      add(this, event, callback)
    })
  }
  $.fn.unbind = function(event, callback){
    return this.each(function(){
      remove(this, event, callback)
    })
  }
  $.fn.one = function(event, callback){
    return this.each(function(i, element){
      add(this, event, callback, null, function(fn, type){
        return function(){
          var result = fn.apply(element, arguments)
          remove(element, type, fn)
          return result
        }
      })
    })
  }

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      }
  function createProxy(event) {
    var proxy = $.extend({originalEvent: event}, event)
    $.each(eventMethods, function(name, predicate) {
      proxy[name] = function(){
        this[predicate] = returnTrue
        return event[name].apply(event, arguments)
      }
      proxy[predicate] = returnFalse
    })
    return proxy
  }

  // emulates the 'defaultPrevented' property for browsers that have none
  function fix(event) {
    if (!('defaultPrevented' in event)) {
      event.defaultPrevented = false
      var prevent = event.preventDefault
      event.preventDefault = function() {
        this.defaultPrevented = true
        prevent.call(this)
      }
    }
  }

  $.fn.delegate = function(selector, event, callback){
    var capture = false
    if(event == 'blur' || event == 'focus'){
      if($.iswebkit)
        event = event == 'blur' ? 'focusout' : event == 'focus' ? 'focusin' : event
      else
        capture = true
    }
    
    return this.each(function(i, element){
      add(element, event, callback, selector, function(fn){
        return function(e){
          var evt, match = $(e.target).closest(selector, element).get(0)
          if (match) {
            evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
            return fn.apply(match, [evt].concat([].slice.call(arguments, 1)))
          }
        }
      }, capture)
    })
  }
  $.fn.undelegate = function(selector, event, callback){
    return this.each(function(){
      remove(this, event, callback, selector)
    })
  }

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback)
    return this
  }
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback)
    return this
  }

  $.fn.on = function(event, selector, callback){
    return selector == undefined || $.isFunction(selector) ?
      this.bind(event, selector) : this.delegate(selector, event, callback)
  }
  $.fn.off = function(event, selector, callback){
    return selector == undefined || $.isFunction(selector) ?
      this.unbind(event, selector) : this.undelegate(selector, event, callback)
  }

  $.fn.trigger = function(event, data){
    if (typeof event == 'string') event = $.Event(event)
    fix(event)
    event.data = data
    return this.each(function(){
      // items in the collection might not be DOM elements
      // (todo: possibly support events on plain old objects)
      if('dispatchEvent' in this) this.dispatchEvent(event)
    })
  }

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, data){
    var e, result
    this.each(function(i, element){
      e = createProxy(typeof event == 'string' ? $.Event(event) : event)
      e.data = data
      e.target = element
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e)
        if (e.isImmediatePropagationStopped()) return false
      })
    })
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback){ return this.bind(event, callback) }
  })

  ;['focus', 'blur'].forEach(function(name) {
    $.fn[name] = function(callback) {
      if (callback) this.bind(name, callback)
      else if (this.length) try { this.get(0)[name]() } catch(e){}
      return this
    }
  })

  $.Event = function(type, props) {
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
    event.initEvent(type, bubbles, true, null, null, null, null, null, null, null, null, null, null, null, null)
    return event
  }

})(Zepto)
;(function($){
  function detect(ua){
    var os = this.os = {}, browser = this.browser = {},
      webkit = ua.match(/WebKit\/([\d.]+)/),
      android = ua.match(/(Android)\s+([\d.]+)/),
      ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
      iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
      webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
      touchpad = webos && ua.match(/TouchPad/),
      kindle = ua.match(/Kindle\/([\d.]+)/),
      silk = ua.match(/Silk\/([\d._]+)/),
      blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/)

    // todo clean this up with a better OS/browser
    // separation. we need to discern between multiple
    // browsers on android, and decide if kindle fire in
    // silk mode is android or not

    if (browser.webkit = !!webkit) browser.version = webkit[1]

    if (android) os.android = true, os.version = android[2]
    if (iphone) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.')
    if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.')
    if (webos) os.webos = true, os.version = webos[2]
    if (touchpad) os.touchpad = true
    if (blackberry) os.blackberry = true, os.version = blackberry[2]
    if (kindle) os.kindle = true, os.version = kindle[1]
    if (silk) browser.silk = true, browser.version = silk[1]
    if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true
  }

  detect.call($, navigator.userAgent)
  // make available to unit tests
  $.__detect = detect

})(Zepto)
;(function($, undefined){
  var prefix = '', eventPrefix, endEventName, endAnimationName,
    vendors = { Webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' },
    document = window.document, testEl = document.createElement('div'),
    supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
    clearProperties = {}

  function downcase(str) { return str.toLowerCase() }
  function normalizeEvent(name) { return eventPrefix ? eventPrefix + name : downcase(name) }

  $.each(vendors, function(vendor, event){
    if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {
      prefix = '-' + downcase(vendor) + '-'
      eventPrefix = event
      return false
    }
  })

  clearProperties[prefix + 'transition-property'] =
  clearProperties[prefix + 'transition-duration'] =
  clearProperties[prefix + 'transition-timing-function'] =
  clearProperties[prefix + 'animation-name'] =
  clearProperties[prefix + 'animation-duration'] = ''

  $.fx = {
    off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined),
    cssPrefix: prefix,
    transitionEnd: normalizeEvent('TransitionEnd'),
    animationEnd: normalizeEvent('AnimationEnd')
  }

  $.fn.animate = function(properties, duration, ease, callback){
    if ($.isObject(duration))
      ease = duration.easing, callback = duration.complete, duration = duration.duration
    if (duration) duration = duration / 1000
    return this.anim(properties, duration, ease, callback)
  }

  $.fn.anim = function(properties, duration, ease, callback){
    var transforms, cssProperties = {}, key, that = this, wrappedCallback, endEvent = $.fx.transitionEnd
    if (duration === undefined) duration = 0.4
    if ($.fx.off) duration = 0

    if (typeof properties == 'string') {
      // keyframe animation
      cssProperties[prefix + 'animation-name'] = properties
      cssProperties[prefix + 'animation-duration'] = duration + 's'
      endEvent = $.fx.animationEnd
    } else {
      // CSS transitions
      for (key in properties)
        if (supportedTransforms.test(key)) {
          transforms || (transforms = [])
          transforms.push(key + '(' + properties[key] + ')')
        }
        else cssProperties[key] = properties[key]

      if (transforms) cssProperties[prefix + 'transform'] = transforms.join(' ')
      if (!$.fx.off && typeof properties === 'object') {
        cssProperties[prefix + 'transition-property'] = Object.keys(properties).join(', ')
        cssProperties[prefix + 'transition-duration'] = duration + 's'
        cssProperties[prefix + 'transition-timing-function'] = (ease || 'linear')
      }
    }

    wrappedCallback = function(event){
      if (typeof event !== 'undefined') {
        if (event.target !== event.currentTarget) return // makes sure the event didn't bubble from "below"
        $(event.target).unbind(endEvent, arguments.callee)
      }
      $(this).css(clearProperties)
      callback && callback.call(this)
    }
    if (duration > 0) this.bind(endEvent, wrappedCallback)

    setTimeout(function() {
      that.css(cssProperties)
      if (duration <= 0) setTimeout(function() {
        that.each(function(){ wrappedCallback.call(this) })
      }, 0)
    }, 0)

    return this
  }

  testEl = null
})(Zepto)
;(function($){
  var jsonpID = 0,
      isObject = $.isObject,
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName)
    $(context).trigger(event, data)
    return !event.defaultPrevented
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data)
  }

  // Number of active Ajax requests
  $.active = 0

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
  }
  function ajaxStop(settings) {
    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context
    if (settings.beforeSend.call(context, xhr, settings) === false ||
        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
      return false

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
  }
  function ajaxSuccess(data, xhr, settings) {
    var context = settings.context, status = 'success'
    settings.success.call(context, data, status, xhr)
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
    ajaxComplete(status, xhr, settings)
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings) {
    var context = settings.context
    settings.error.call(context, xhr, type, error)
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])
    ajaxComplete(type, xhr, settings)
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context
    settings.complete.call(context, xhr, status)
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
    ajaxStop(settings)
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function(options){
    var callbackName = 'jsonp' + (++jsonpID),
      script = document.createElement('script'),
      abort = function(){
        $(script).remove()
        if (callbackName in window) window[callbackName] = empty
        ajaxComplete('abort', xhr, options)
      },
      xhr = { abort: abort }, abortTimeout

    if (options.error) script.onerror = function() {
      xhr.abort()
      options.error()
    }

    window[callbackName] = function(data){
      clearTimeout(abortTimeout)
      $(script).remove()
      delete window[callbackName]
      ajaxSuccess(data, xhr, options)
    }

    serializeData(options)
    script.src = options.url.replace(/=\?/, '=' + callbackName)
    $('head').append(script)

    if (options.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.abort()
        ajaxComplete('timeout', xhr, options)
      }, options.timeout)

    return xhr
  }

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest()
    },
    // MIME types mapping
    accepts: {
      script: 'text/javascript, application/javascript',
      json:   jsonType,
      xml:    'application/xml, text/xml',
      html:   htmlType,
      text:   'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0
  }

  function mimeToDataType(mime) {
    return mime && ( mime == htmlType ? 'html' :
      mime == jsonType ? 'json' :
      scriptTypeRE.test(mime) ? 'script' :
      xmlTypeRE.test(mime) && 'xml' ) || 'text'
  }

  function appendQuery(url, query) {
    return (url + '&' + query).replace(/[&?]{1,2}/, '?')
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (isObject(options.data)) options.data = $.param(options.data)
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))
      options.url = appendQuery(options.url, options.data)
  }

  $.ajax = function(options){
    var settings = $.extend({}, options || {})
    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]

    ajaxStart(settings)

    if (!settings.crossDomain) settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) &&
      RegExp.$2 != window.location.host

    var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url)
    if (dataType == 'jsonp' || hasPlaceholder) {
      if (!hasPlaceholder) settings.url = appendQuery(settings.url, 'callback=?')
      return $.ajaxJSONP(settings)
    }

    if (!settings.url) settings.url = window.location.toString()
    serializeData(settings)

    var mime = settings.accepts[dataType],
        baseHeaders = { },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = $.ajaxSettings.xhr(), abortTimeout

    if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'
    if (mime) {
      baseHeaders['Accept'] = mime
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
      xhr.overrideMimeType && xhr.overrideMimeType(mime)
    }
    if (settings.contentType || (settings.data && settings.type.toUpperCase() != 'GET'))
      baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')
    settings.headers = $.extend(baseHeaders, settings.headers || {})

    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4) {
        clearTimeout(abortTimeout)
        var result, error = false
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
          dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))
          result = xhr.responseText

          try {
            if (dataType == 'script')    (1,eval)(result)
            else if (dataType == 'xml')  result = xhr.responseXML
            else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)
          } catch (e) { error = e }

          if (error) ajaxError(error, 'parsererror', xhr, settings)
          else ajaxSuccess(result, xhr, settings)
        } else {
          ajaxError(null, 'error', xhr, settings)
        }
      }
    }

    var async = 'async' in settings ? settings.async : true
    xhr.open(settings.type, settings.url, async)

    for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort()
      return false
    }

    if (settings.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.onreadystatechange = empty
        xhr.abort()
        ajaxError(null, 'timeout', xhr, settings)
      }, settings.timeout)

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null)
    return xhr
  }

  $.get = function(url, success){ return $.ajax({ url: url, success: success }) }

  $.post = function(url, data, success, dataType){
    if ($.isFunction(data)) dataType = dataType || success, success = data, data = null
    return $.ajax({ type: 'POST', url: url, data: data, success: success, dataType: dataType })
  }

  $.getJSON = function(url, success){
    return $.ajax({ url: url, success: success, dataType: 'json' })
  }

  $.fn.load = function(url, success){
    if (!this.length) return this
    var self = this, parts = url.split(/\s/), selector
    if (parts.length > 1) url = parts[0], selector = parts[1]
    $.get(url, function(response){
      self.html(selector ?
        $(document.createElement('div')).html(response.replace(rscript, "")).find(selector).html()
        : response)
      success && success.call(self)
    })
    return this
  }

  var escape = encodeURIComponent

  function serialize(params, obj, traditional, scope){
    var array = $.isArray(obj)
    $.each(obj, function(key, value) {
      if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value)
      // recurse into nested objects
      else if (traditional ? $.isArray(value) : isObject(value))
        serialize(params, value, traditional, key)
      else params.add(key, value)
    })
  }

  $.param = function(obj, traditional){
    var params = []
    params.add = function(k, v){ this.push(escape(k) + '=' + escape(v)) }
    serialize(params, obj, traditional)
    return params.join('&').replace('%20', '+')
  }
})(Zepto)
;(function ($) {
  $.fn.serializeArray = function () {
    var result = [], el
    $( Array.prototype.slice.call(this.get(0).elements) ).each(function () {
      el = $(this)
      var type = el.attr('type')
      if (this.nodeName.toLowerCase() != 'fieldset' &&
        !this.disabled && type != 'submit' && type != 'reset' && type != 'button' &&
        ((type != 'radio' && type != 'checkbox') || this.checked))
        result.push({
          name: el.attr('name'),
          value: el.val()
        })
    })
    return result
  }

  $.fn.serialize = function () {
    var result = []
    this.serializeArray().forEach(function (elm) {
      result.push( encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value) )
    })
    return result.join('&')
  }

  $.fn.submit = function (callback) {
    if (callback) this.bind('submit', callback)
    else if (this.length) {
      var event = $.Event('submit')
      this.eq(0).trigger(event)
      if (!event.defaultPrevented) this.get(0).submit()
    }
    return this
  }

})(Zepto)
;(function($){
  var touch = {}, touchTimeout

  function parentIfText(node){
    return 'tagName' in node ? node : node.parentNode
  }

  function swipeDirection(x1, x2, y1, y2){
    var xDelta = Math.abs(x1 - x2), yDelta = Math.abs(y1 - y2)
    return xDelta >= yDelta ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')
  }

  var longTapDelay = 750, longTapTimeout

  function longTap(){
    longTapTimeout = null
    if (touch.last) {
      touch.el.trigger('longTap')
      touch = {}
    }
  }

  function cancelLongTap(){
    if (longTapTimeout) clearTimeout(longTapTimeout)
    longTapTimeout = null
  }

  $(document).ready(function(){
    var now, delta

    $(document.body).bind('touchstart', function(e){
      now = Date.now()
      delta = now - (touch.last || now)
      touch.el = $(parentIfText(e.touches[0].target))
      touchTimeout && clearTimeout(touchTimeout)
      touch.x1 = e.touches[0].pageX
      touch.y1 = e.touches[0].pageY
      if (delta > 0 && delta <= 250) touch.isDoubleTap = true
      touch.last = now
      longTapTimeout = setTimeout(longTap, longTapDelay)
    }).bind('touchmove', function(e){
      cancelLongTap()
      touch.x2 = e.touches[0].pageX
      touch.y2 = e.touches[0].pageY
    }).bind('touchend', function(e){
       cancelLongTap()

      // double tap (tapped twice within 250ms)
      if (touch.isDoubleTap) {
        touch.el.trigger('doubleTap')
        touch = {}

      // swipe
      } else if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||
                 (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30)) {
        touch.el.trigger('swipe') &&
          touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))
        touch = {}

      // normal tap
      } else if ('last' in touch) {
        touch.el.trigger('tap')

        touchTimeout = setTimeout(function(){
          touchTimeout = null
          touch.el.trigger('singleTap')
          touch = {}
        }, 250)
      }
    }).bind('touchcancel', function(){
      if (touchTimeout) clearTimeout(touchTimeout)
      if (longTapTimeout) clearTimeout(longTapTimeout)
      longTapTimeout = touchTimeout = null
      touch = {}
    })
  })

  ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(m){
    $.fn[m] = function(callback){ return this.bind(m, callback) }
  })
})(Zepto)

/* **********************************************
     Begin zepto-onpress.js
********************************************** */

/* Author:
    Max Degterev @suprMax
    
    Zepto fast buttons without nasty ghostclicks.
    Supports delegation and handlers removal, though removal feels a bit hacky and needs to be tested.
    Highly inspired by http://code.google.com/mobile/articles/fast_buttons.html
    
    Usage
    
    bind:
    $('#someid').onpress(function(event){});
    $('#someid').offpress(function(event){});
    
    delegation:
    $('#someid').onpress('.childNode', function(event){});
    $('#someid').offpress('.childNode', function(event){});
    
*/

;(function($) {
    // Zepto touch device detection
    $.os.touch = !(typeof window.ontouchstart === 'undefined');
    
    var ghostsLifeTime = 2500;
    
    var normalizeArgs = function(args) {
        var callback,
            selector;
            
        if (typeof args[0] === 'function') {
            callback = args[0];
        }
        else {
            selector = args[0];
            callback = args[1];
        }
        return [selector, callback];
    };

    if ($.os.touch) {
        var ghosts = [];

        var touches = {},
            $doc = $(document),
            hasMoved = false,
            handlers = {};
            
        var handleTouchStart = function(e) {
            e.stopPropagation();

            touches.x = e.touches[0].pageX;
            touches.y = e.touches[0].pageY;
            hasMoved = false;
        };

        var handleMove = function(e) {
            if (Math.abs(e.touches[0].pageX - touches.x) > 10 || Math.abs(e.touches[0].pageX - touches.y) > 10) {
                hasMoved = true;
            }
        };

        var removeGhosts = function() {
            ghosts.splice(0, 2);
        };

        var handleGhosts = function(e) {
            var i, l;
            for (i = 0, l = ghosts.length; i < l; i += 2) {
                if (Math.abs(e.pageX - ghosts[i]) < 25 && Math.abs(e.pageY - ghosts[i + 1]) < 25) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        };

        $doc.on('click', handleGhosts);
        $doc.on('touchmove', handleMove);

        $.fn.onpress = function() {
            var args = normalizeArgs(arguments);
            
            var handleTouchEnd = function(e) {
                e.stopPropagation();

                if (!hasMoved) {
                    args[1].call(this, e);
                    ghosts.push(touches.x, touches.y);
                    window.setTimeout(removeGhosts, ghostsLifeTime);
                }
            };
            
            handlers[args[1]] = handleTouchEnd;

            if (args[0]) {
                this.on('touchstart.onpress', args[0], handleTouchStart);
                this.on('touchend.onpress', args[0], handleTouchEnd);
                this.on('press', args[0], args[1]);
            }
            else {
                this.on('touchstart.onpress', handleTouchStart);
                this.on('touchend.onpress', handleTouchEnd);
                this.on('press', args[1]);
            }
        };
        
        $.fn.offpress = function() {
            var args = normalizeArgs(arguments);
            if (args[1]) {
                if (args[0]) {
                    this.off('.onpress', args[0], handlers[args[1]]);
                    this.off('press', args[0], args[1]);
                }
                else {
                    this.off('.onpress', handlers[args[1]]);
                    this.off('press', args[1]);
                }
                delete handlers[args[1]];
            }
            else {
                if (args[0]) {
                    this.off('.onpress', args[0]);
                    this.off('press', args[0]);
                }
                else {
                    this.off('.onpress');
                    this.off('press');
                }
            }
        };
    }
    else {
        $.fn.onpress = function() {
            var args = normalizeArgs(arguments);
            if (args[0]) {
                this.on('click.onpress', args[0], args[1]);
                this.on('press.onpress', args[0], args[1]);
            }
            else {
                this.on('click.onpress', args[1]);
                this.on('press.onpress', args[1]);
            }
            
        };
        $.fn.offpress = function() {
            var args = normalizeArgs(arguments);
            args[0] ? this.off('.onpress', args[0], args[1]) : this.off('.onpress', args[1]);
        };
    }
})(Zepto);

/* **********************************************
     Begin flickable.js
********************************************** */

// BoostCommunications' Flickable.js: https://github.com/BoostCommunications/Flickable
// Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php

var Flickable = function(elementSelector, options) {

    var elements = [],
        elementRegex = new RegExp('^([#.])([^#.,> ]+)'),
        elementMatches = elementRegex.exec(elementSelector),
        i, j,
        events,
        settings = {
            width: 'screen',
            offset: 0,
            enableMouseEvents: false,
            showIndicators: true,
            showButtons: false,
            indicatorClass: 'flickableIndicator',
            activeIndicatorClass: 'flickableIndicatorActive',
            slideshowNavigationClass: 'slideshowNavigation',
            nextButtonClass: 'nextSlideButton',
            prevButtonClass: 'prevSlideButton',
            nextButtonText: 'Next',
            prevButtonText: 'Previous'
        },
        orientationEvent = 'resize',
        orientationTimeout;

    if (elementMatches[1] === '.') {
        elements = document.getElementsByClassName(elementMatches[2]);
    } else if (elementMatches[1] === '#') {
        elements = [document.getElementsById(elementMatches[2])];
    }

    if ('onorientationchange' in window) {
        orientationEvent = 'orientationchange';
    }

    // Extend settings with options from parameter
    if (options) {
        for (i in options) {
            if (options.hasOwnProperty(i)) {
                settings[i] = options[i];
            }
        }
    }

    if (settings.itemWidth) {
        settings.width = settings.itemWidth;
    }

    if (settings.width == 'screen') {
        settings.widthScreen = true;
        settings.width = window.innerWidth;
        window.addEventListener(orientationEvent, function(e) {
            clearTimeout(orientationTimeout);
            orientationTimeout = setTimeout(function() {
                settings.width = window.innerWidth;
            }, 200);
        });
    }

    // Detect if current device supports touch events, otherwise use mouse events
    if ('ontouchstart' in document.createElement('div')) {
        events = {
            start: 'touchstart',
            move: 'touchmove',
            end: 'touchend'
        };
    } else if (settings.enableMouseEvents) {
        events = {
            start: 'mousedown',
            move: 'mousemove',
            end: 'mouseup'
        };
    }

    // Generate next/previous slide buttons
    var createButtons = function(prevCallback, nextCallback) {
        var slideshowNavigation = document.createElement('div'),
            nextButton = document.createElement('a'),
            prevButton = document.createElement('a');

        slideshowNavigation.className = settings.slideshowNavigationClass;
        nextButton.className = settings.nextButtonClass;
        prevButton.className = settings.prevButtonClass;
        nextButton.href = '#';
        prevButton.href = '#';

        if (settings.nextButtonText) {
            nextButton.innerHTML = settings.nextButtonText;
        }

        if (settings.prevButtonText) {
            prevButton.innerHTML = settings.prevButtonText;
        }

        // Set up events for next/previous buttons
        prevButton.addEventListener('click', function(evt) {
            evt.preventDefault();
            prevCallback();
        });

        nextButton.addEventListener('click', function(evt) {
            evt.preventDefault();
            nextCallback();
        });

        slideshowNavigation.appendChild(prevButton);
        slideshowNavigation.appendChild(nextButton);

        return slideshowNavigation;
    };

    // Set up flickables for all matched elements
    for (i = 0, j = elements.length; i < j; i++) {
        (function(i) {

            var element = elements[i],
                item = element.children[0],
                subItems = item.children,
                subItemCount = subItems.length,
                currentSlide = settings.offset,
                previousSlide = currentSlide,
                offset,
                k;

            if (settings.showIndicators) {
                var indicator = document.createElement('div');
                indicator.setAttribute('class', settings.indicatorClass);

                for (k = 0; k < subItemCount; k++) {
                    indicator.appendChild(document.createElement('span'));
                }

                indicator.childNodes[currentSlide].setAttribute('class', settings.activeIndicatorClass);
                element.parentNode.insertBefore(indicator, element.nextSibling);
            }

            var updateIndicators = function() {
                if (settings.showIndicators) {
                    var indicators = indicator.childNodes;
                    for (var k = 0, l = indicators.length; k < l; k++) {
                        if (k !== currentSlide) {
                            indicators[k].removeAttribute('class');
                        } else {
                            indicators[k].setAttribute('class', settings.activeIndicatorClass);
                        }
                    }
                }
            };

            var callCallback = function() {
                if (settings.callback) {
                    setTimeout(function() {
                        if (currentSlide !== previousSlide) {
                            settings.callback(currentSlide);
                            previousSlide = currentSlide;
                        }
                    }, 200);
                }
            };

            // Use touch events and transforms on fancy phones
            if (events) {
                var enableAnimation = function() {
                    item.style.WebkitTransition = '-webkit-transform 0.4s ease';
                    item.style.MozTransition = '-moz-transform 0.4s ease';
                    item.style.OTransition = '-o-transform 0.4s ease';
                    item.style.transition = 'transform 0.4s ease';
                };

                var disableAnimation = function() {
                    item.style.WebkitTransition = '';
                    item.style.MozTransition = '';
                    item.style.OTransition = '';
                    item.style.transition = '';
                };

                var snapToCurrentSlide = function(showAnimation) {
                    if (showAnimation) {
                        enableAnimation();
                    } else {
                        disableAnimation();
                    }
                    offset = -(currentSlide * settings.width);

                    item.style.WebkitTransform = 'translate3d(' + offset + 'px, 0, 0)';
                    item.style.MozTransform = 'translateX(' + offset + 'px)';
                    item.style.OTransform = 'translateX(' + offset + 'px)';
                    item.style.transform = 'translate3d(' + offset + 'px, 0, 0)';
                    callCallback();
                    updateIndicators();
                };

                var resetWidths = function() {
                    snapToCurrentSlide(false);
                    item.style.width = (settings.width * subItemCount) + 'px';

                    for (k = 0; k < subItemCount; k++) {
                        subItems[k].style.width = settings.width + 'px';
                    }
                };

                resetWidths();

                window.addEventListener(orientationEvent, function() {
                    setTimeout(function() {
                        resetWidths();
                    }, 400);
                });

                // Show buttons if wanted
                if (settings.showButtons) {
                    element.appendChild(createButtons(function() {
                        currentSlide = currentSlide - 1;
                        if (!subItems[currentSlide]) {
                            currentSlide = subItemCount - 1;
                        }
                        snapToCurrentSlide(true);
                    }, function() {
                        currentSlide = currentSlide + 1;
                        if (!subItems[currentSlide]) {
                            currentSlide = 0;
                        }
                        snapToCurrentSlide(true);
                    }));
                }

                // Get X and Y value from a touch or mouse event
                var getXY = function(evt) {
                    if (evt.targetTouches && evt.targetTouches.length) {
                        var i = 0,
                            j = evt.targetTouches.length,
                            sumX = 0,
                            sumY = 0;
                        for ( ; i < j; i++) {
                            sumX += evt.targetTouches[i].clientX;
                            sumY += evt.targetTouches[i].clientY;
                        }
                        return [sumX / j, sumY / j];
                    } else {
                        return [evt.clientX, evt.clientY];
                    }
                };
try {
                // Set up touch listener
                element.addEventListener(events.start, function(evt) {

                    // Get origin position
                    var origin = getXY(evt),
                        current = origin,
                        prevTime = (new Date()).getTime(),
                        speed = 0;

                    disableAnimation();

                    // Reposition gallery based on event
                    var reposition = function(evt) {
                        var distanceX = Math.abs(current[0] - origin[0]),
                            distanceY = Math.abs(current[1] - origin[1]),
                            newTime = (new Date()).getTime();

                        speed = (current[0] - origin[0]) / (newTime - prevTime);
                        prevTime = newTime;

                        // Only scroll gallery if X distance is greater than Y distance
                        if (distanceX > distanceY) {
                            evt.stopPropagation();
                            evt.preventDefault();
                        } else {
                            current[0] = origin[0];
                        }

                        // Get delta X distance
                        var delta = current[0] - origin[0];

                        // Make scrolling "sticky" if we are scrolling past the first or last panel
                        if (offset + delta > 0 || offset + delta < -((subItemCount-1) * settings.width)) {
                            delta = Math.floor(delta / 2);
                        }

                        // Update position
                        item.style.WebkitTransform = 'translate3d(' + (offset + delta) + 'px, 0, 0)';
                        item.style.MozTransform = 'translateX(' + (offset + delta) + 'px)';
                        item.style.OTransform = 'translateX(' + (offset + delta) + 'px)';
                        item.style.transform = 'translate3d(' + (offset + delta) + 'px, 0, 0)';
                    };

                    var moveEvent = function(evt) {
                        current = getXY(evt);
                        reposition(evt);
                    };

                    var endEvent = function(evt) {
                        var diff = current[0] - origin[0] + ((speed / settings.width) * 12000);

                        // Snap to closest panel
                        if (diff > settings.width / 2 && offset !== 0) {
                            current[0] = origin[0] + settings.width;
                            offset = offset + settings.width;
                        } else if (diff < -(settings.width / 2) && offset != -((subItemCount - 1) * settings.width)) {
                            current[0] = origin[0] - settings.width;
                            offset = offset - settings.width;
                        } else {
                            current[0] = origin[0];
                        }

                        currentSlide = Math.floor(Math.abs(offset/settings.width));
                        snapToCurrentSlide(true);

                        // Remove drag and end event listeners
                        element.removeEventListener(events.move, moveEvent, false);
                        element.removeEventListener(events.end, endEvent, false);
                    };

                    // Set up drag and end event listeners
                    element.addEventListener(events.move, moveEvent, false);
                    element.addEventListener(events.end, endEvent, false);

                }, false);
} catch (e) {

}
            // Use buttons and stuff on boring phones
            } else {
                // Hide all slides but the active one
                var hideInactiveSlides = function() {
                    for (k = 0; k < subItemCount; k++) {
                        if (k !== currentSlide) {
                            subItems[k].style.display = 'none';
                        } else {
                            subItems[k].style.display = '';
                        }
                    }
                };
                hideInactiveSlides();

                element.appendChild(createButtons(function() {
                    currentSlide = currentSlide - 1;
                    if (!subItems[currentSlide]) {
                        currentSlide = subItemCount - 1;
                    }
                    hideInactiveSlides();
                    callCallback();
                    updateIndicators();
                }, function() {
                    currentSlide = currentSlide + 1;
                    if (!subItems[currentSlide]) {
                        currentSlide = 0;
                    }
                    hideInactiveSlides();
                    callCallback();
                    updateIndicators();
                }));
            }
        })(i);
    }
};

/* **********************************************
     Begin init.js
********************************************** */

window.onload = init;

var arp = true;
var play = false;

var context;
var staticAudioRouting;

var loader;
var startTime;

var cutoff = 0;
var resonance = 0;
var envAmount = 0.5;
var width = 0.6;
var detune1 = 4.5;
var detune2 = -2.5;
var octave = 0;

var defaultWaveTableName = "01_Saw";
var waveTable;
var waveTable2;

var volume = 1;
var filterAttack = 0.056;
var filterDecay = 0.991;
var ampAttack = 0.056;
var ampDecay = 0.100;
var playDoubleOctave = false;
var grungeDrive = 1;

var views;
var sequence;
var sequenceView;

var isShiftDown = false;
var isAltDown = false;

var monophonicNote;
var playMonophonic = true;

function onDocumentKeyDown( event ) {
    switch( event.keyCode ) {

        case 16:
            isShiftDown = true;
            break;
        case 18:
            isAltDown = true;
            break;
    }

    // window.console.log(sequence.rhythm);
}

function onDocumentKeyUp( event ) {
    switch( event.keyCode ) {
        case 16:
            isShiftDown = false;
            break;
        case 18:
            isAltDown = false;
            break;
    }
}

if ( !window.requestAnimationFrame ) {
    window.requestAnimationFrame = ( function() {

    return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

    window.setTimeout( callback, 1000 / 60 );
};

} )();
}

function loadWaveTables() {
    loader = new WaveTableLoader();
    loader.load(start);
}

function WaveTableLoader() {
    this.waveNames = [
        "01_Saw",
        "02_Triangle",
        "03_Square",
        "04_Noise",
        "05_Pulse"
        //,
        // "06_Warm_Saw",
        // "07_Warm_Triangle",
        // "08_Warm_Square",
        // "09_Dropped_Saw",
        // "10_Dropped_Square",
        // "11_TB303_Square",
        // "Bass",
        // "Bass_Amp360",
        // "Bass_Fuzz",
        // "Bass_Fuzz_ 2",
        // "Bass_Sub_Dub",
        // "Bass_Sub_Dub_2",
        // "Brass",
        // "Brit_Blues",
        // "Brit_Blues_Driven",
        // "Buzzy_1",
        // "Buzzy_2",
        // "Celeste",
        // "Chorus_Strings",
        // "Dissonant Piano",
        // "Dissonant_1",
        // "Dissonant_2",
        // "Dyna_EP_Bright",
        // "Dyna_EP_Med",
        // "Ethnic_33",
        // "Full_1",
        // "Full_2",
        // "Guitar_Fuzz",
        // "Harsh",
        // "Mkl_Hard",
        // "Organ_2",
        // "Organ_3",
        // "Phoneme_ah",
        // "Phoneme_bah",
        // "Phoneme_ee",
        // "Phoneme_o",
        // "Phoneme_ooh",
        // "Phoneme_pop_ahhhs",
        // "Piano",
        // "Putney_Wavering",
        // "Throaty",
        // "Trombone",
        // "Twelve String Guitar 1",
        // "Twelve_OpTines",
        // "Wurlitzer",
        // "Wurlitzer_2",
    ];
}

WaveTableLoader.prototype.load = function(finishedCallback) {
    var loader = this;

    loader.finishedCallback = finishedCallback;
    loader.loadedCount = 0;
    loader.waveList = new Array();

    for (var i = 0; i < loader.waveNames.length; ++i) {
        var name = loader.waveNames[i];
        loader.waveList[i] = new WaveTable(name, context);
        loader.waveList[i].load(function(waveTable) {
            loader.loadedCount++;
            if (loader.loadedCount == loader.waveList.length)
                loader.finishedCallback();
        }
        );

    }
}

WaveTableLoader.prototype.makeWavePopup = function(popupName) {
    var waveList = document.getElementById(popupName);

    var numWaves = this.waveNames.length;

    for (var i = 0; i < numWaves; i++) {
        var item = document.createElement('option');
        item.innerHTML = this.waveNames[i];

        if (this.waveNames[i] == defaultWaveTableName)
            item.selected = "selected";

        waveList.appendChild(item);
    }
}

WaveTableLoader.prototype.getTable = function(name) {
    for (var i = 0; i < this.waveNames.length; ++i) {
        if (name == this.waveNames[i]) {
            return this.waveList[i];
        }
    }
}

if ( !window.requestAnimationFrame ) {
    window.requestAnimationFrame = ( function() {

    return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

    window.setTimeout( callback, 1000 / 60 );
};

} )();
}

function SequenceView(sequence, divName) {
    this.sequence = sequence;
    this.name = divName;
    this.numberOfNotes = sequence.loopLength;
    this.numSemitones = 60;
    this.backgroundColor = "#FFF";
    this.noteColor = "#333";
    this.gridColor = "#007356";
    this.playheadColor = "#00BF8F";

    this.canvas = document.getElementById(divName);
    this.ctx = this.canvas.getContext('2d');
    this.width = this.canvas.width;
    this.height = this.canvas.height;

    var view = this;
    var canvas = this.canvas;

    canvas.addEventListener("mousedown",
        function(event) {
            var eventInfo = {event: event, element:view.canvas};
            var position = getRelativeCoordinates(eventInfo);
            currentView = view;
            view.isDragging = true;
            view.startPosition = position;
            view.mouseDown(position);
        },
        true
    );

    // Note: document handles mouseup and mousemove events.
    document.addEventListener("mousemove",
        function(event) {
            if (currentView && currentView == view) {
                var c = getAbsolutePosition(currentView.canvas);
                c.x = event.x - c.x;
                c.y = event.y - c.y;

                var position = c;

                // This isn't the best, should abstract better.
                if (isNaN(c.y)) {
                    var eventInfo = {event: event, element:currentView.canvas};
                    position = getRelativeCoordinates(eventInfo);
                }

                currentView.mouseMove(position);
            }
        },
        true
    );

    document.addEventListener("mouseup",
        function(event) {
            if (currentView && currentView == view) {
                view.isDragging = false;
                var eventInfo = {event: event, element:currentView.canvas};
                var position = getRelativeCoordinates(eventInfo);
                currentView.mouseUp(position);
                currentView = 0;
            }
        },
        true
    );

    this.draw();

    this.drawPlayhead();
}

SequenceView.prototype.draw = function() {
    var ctx = this.ctx;
    var width = this.width;
    var height = this.height;

    // Draw background.
    ctx.fillStyle = this.backgroundColor;
    ctx.fillRect(0,0, width, height);

    // Draw grid.
    var n = this.numberOfNotes;
    ctx.strokeStyle = this.gridColor;
    ctx.lineWidth = 1;
    for (var i = 0; i < n; ++i) {
        var x = i * width / n;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }

    // Draw notes.
    var noteWidth = width / n;
    var numSemitones = this.numSemitones;
    var noteHeight = height / numSemitones;
    for (var i = 0; i < n; ++i) {
        if (sequence.rhythm[i] != -1) {
            var x = i * width / n;
            var y = -noteHeight + height - sequence.rhythm[i]*noteHeight;
            ctx.fillStyle = this.noteColor;
            ctx.fillRect(x, y, noteWidth, noteHeight);
        }
    }
}


SequenceView.prototype.drawPlayhead = function() {
    var ctx = this.ctx;
    var width = this.width;
    var height = this.height;
    var n = this.numberOfNotes;

    var noteWidth = width / n;
    var numSemitones = this.numSemitones;
    var noteHeight = height / numSemitones;

    if (this.sequence.lastRhythmIndex != this.lastDrawnRhythmIndex) {
        // Erase last playhead
        var x = this.lastDrawnRhythmIndex * width / n;
        var y = 0;
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(x, y, noteWidth, noteHeight);

        // Draw new playhead
        var x = this.sequence.lastRhythmIndex * width / n;
        var y = 0;
        ctx.fillStyle = this.playheadColor;
        ctx.fillRect(x, y, noteWidth, noteHeight);

        this.lastDrawnRhythmIndex = this.sequence.lastRhythmIndex;
    }

    var view = this;
    function requestDispatch() {
        view.drawPlayhead();
    }

    window.requestAnimationFrame(requestDispatch);
}


SequenceView.prototype.mouseDown = function(position) {
    var width = this.width;
    var height = this.height;
    var n = this.numberOfNotes;
    var noteWidth = width / n;
    var numSemitones = this.numSemitones;
    var noteHeight = height / numSemitones;
    var ri = Math.floor(position.x / noteWidth);
    var note = Math.floor( (height - position.y) / noteHeight);
    if (ri >= 0 && ri < n && note >= 0) {
        if (isAltDown)
            sequence.rhythm[ri] = -1;
        else
            sequence.rhythm[ri] = note;

        this.draw();
    }
}

SequenceView.prototype.mouseMove = function(position) {
    if (this.isDragging) {
        this.mouseDrag(position);
    }
}

SequenceView.prototype.mouseDrag = function(position) {
}

SequenceView.prototype.mouseUp = function(position) {
}



var tempo = 120.0;


function Sequence() {
    this.loopLength = 8;
    this.rhythmIndex = 1;
    this.lastRhythmIndex = -1;
    this.loopNumber = 0;
    this.noteTime = 0.0;

    this.rhythm = [4, 4, 4, -1, 8, 13, 25, 15, 33, 23, 11, -1, 0, -1, 3, -1];
    // this.minor = [0, 3, 7, 10, 12, 15, 19, 22, 24, 27, 31, 34, 36, 39, 43, 46, 48, 51, 55, 58];
}

Sequence.prototype.advanceNote = function() {
    // Advance time by a 16th note...
    var secondsPerBeat = 60.0 / tempo;
    this.noteTime += 0.25 * secondsPerBeat;

    this.lastRhythmIndex = this.rhythmIndex;

    this.rhythmIndex++;
    if (this.rhythmIndex == this.loopLength) {
        this.rhythmIndex = 0;
        this.loopNumber++
    }
}

function ddd() {
    sequence.schedule();
}

Sequence.prototype.schedule = function() {
    var currentTime = context.currentTime;

    // The sequence starts at startTime, so normalize currentTime so that it's 0 at the start of the sequence.
    currentTime -= startTime;

    while (this.noteTime < currentTime + 0.040 /*0.120*/) {
        // Convert noteTime to context time.
        var contextPlayTime = this.noteTime + startTime;

        if (this.rhythm[this.rhythmIndex] != -1) {
            var noteNumber = this.rhythm[this.rhythmIndex];
            if (arp) {

                var minor = [0, 3, 7, 10];
                var arpOctave = Math.floor(noteNumber / 4);
                var i = noteNumber % 4;
                noteNumber = minor[i] + 12 * arpOctave;
            }

            if (playMonophonic) {
                monophonicNote.play(waveTable, waveTable2, noteNumber, octave, contextPlayTime);
            } else {
                var note = new Note(staticAudioRouting, false);
                note.play(waveTable, waveTable2, noteNumber, octave, contextPlayTime);

                if (playDoubleOctave) {
                    var note2 = new Note(staticAudioRouting, false);
                    note2.play(waveTable, waveTable2, noteNumber + 12, octave, contextPlayTime);
                }

            }

        }

        this.advanceNote();
    }

    setTimeout("ddd()", 0);
}

function Note(staticAudioRouting, isMonophonic) {
    this.staticAudioRouting = staticAudioRouting;
    this.isMonophonic = isMonophonic;

    // Create oscillators, panners, amplitude, and filter envelopes.

    var osc1 = context.createBufferSource();
    osc1.looping = true;

    var osc1Octave = context.createBufferSource();
    osc1Octave.looping = true;

    var osc2 = context.createBufferSource();
    osc2.looping = true;

    var osc2Octave = context.createBufferSource();
    osc2Octave.looping = true;

    var panner1 = context.createPanner();
    panner1.panningModel = webkitAudioPannerNode.EQUALPOWER;

    var panner2 = context.createPanner();
    panner2.panningModel = webkitAudioPannerNode.EQUALPOWER;

    // Amplitude envelope
    var ampEnvelope = context.createGainNode();
    ampEnvelope.gain.value = 0.0; // default value

    // Filter
    var filter = context.createBiquadFilter();
    filter.type = 0;
    filter.gain.value = 0.0; // default value

    // Create note volume.
    var noteVolume = context.createGainNode();
    noteVolume.gain.value = 0; // start out silent until told otherwise

    // Make connections

    // oscillators --> panners.
    osc1.connect(panner1);
    osc1Octave.connect(panner1);
    osc2.connect(panner2);
    osc2Octave.connect(panner2);

    // panners --> amplitude envelope
    panner1.connect(ampEnvelope);
    panner2.connect(ampEnvelope);

    // amplitude envelope --> filter envelope
    ampEnvelope.connect(filter);

    // filter envelope --> note volume
    filter.connect(noteVolume);

    // note volume -> subsonic filter
    noteVolume.connect(this.staticAudioRouting.subsonicFilter /*subsonicFilter*/);

    // Keep oscillators playing at all times if monophonic.
    if (this.isMonophonic) {
        osc1.noteOn(0);
        osc2.noteOn(0);
        osc1Octave.noteOn(0);
        osc2Octave.noteOn(0);
    }

    // Keep track of all the nodes.
    this.osc1 = osc1;
    this.osc2 = osc2;
    this.osc1Octave = osc1Octave;
    this.osc2Octave = osc2Octave;
    this.panner1 = panner1;
    this.panner2 = panner2;
    this.ampEnvelope = ampEnvelope;
    this.filter = filter;
    this.noteVolume = noteVolume;

    this.wave = 0;
    this.wave2 = 0;
}

Note.prototype.setFilterValues = function() {
    var time = this.time;
    var filter = this.filter;
    var pitchFrequency = this.pitchFrequency;

    filter.frequency.cancelScheduledValues(0);

    filter.type = 0; // Lowpass
    filter.Q.value = resonance; // !!FIXME: should be Q

    var nyquist = 0.5 * context.sampleRate;

    var cutoffCents = 9600 * cutoff;
    var cutoffRate = Math.pow(2, cutoffCents / 1200.0);
    var startFrequency = cutoffRate * pitchFrequency;
    if (startFrequency > nyquist)
        startFrequency = nyquist;

    var envAmountCents = 7200 * envAmount;
    var envAmountRate = Math.pow(2, envAmountCents / 1200.0);
    var envAmountFrequency = startFrequency * envAmountRate;
    if (envAmountFrequency > nyquist)
        envAmountFrequency = nyquist;

    if (!this.isMonophonic) {
        filter.frequency.value = startFrequency;
        filter.frequency.setValueAtTime(startFrequency, time);
    } else {
        // filter.frequency.setValueAtTime(filter.frequency.value, time); // !! not correct
    }

    filter.frequency.setTargetValueAtTime(envAmountFrequency, time, filterAttack);
    filter.frequency.setTargetValueAtTime(startFrequency, time + filterAttack, filterDecay);
}

var firstTime = true;

Note.prototype.play = function(wave, wave2, semitone, octave, time) {
    this.time = time;

    if (wave != this.wave || wave2 != this.wave2 || !this.isMonophonic) {
        this.wave = wave;
        this.wave2 = wave2;
        firstTime = true;
    }

    // Get local copies.
    var osc1 = this.osc1;
    var osc2 = this.osc2;
    var osc1Octave = this.osc1Octave;
    var osc2Octave = this.osc2Octave;
    var panner1 = this.panner1;
    var panner2 = this.panner2;
    var ampEnvelope = this.ampEnvelope;
    var filter = this.filter;
    var noteVolume = this.noteVolume;

    // Set oscillator pitches.

    var pitchFrequency = 20.0 /*440.0*/ * Math.pow(2.0, semitone / 12.0);
    this.pitchFrequency = pitchFrequency;

    var pitchRate = pitchFrequency * wave.getRateScale();

    var rate1 = pitchRate * Math.pow(2.0, -detune1/1200);
    var buffer1 = wave.getWaveDataForPitch(rate1);
    if (firstTime) osc1.buffer = buffer1;

    osc1.playbackRate.value = rate1;


    var rate2 = pitchRate * Math.pow(2.0, octave - detune2/1200);
    var buffer2 = wave2.getWaveDataForPitch(rate2);
    if (firstTime) osc1Octave.buffer = buffer2;
    osc1Octave.playbackRate.value = rate2;

    if (firstTime) osc2.buffer = buffer1;
    osc2.playbackRate.value = pitchRate * Math.pow(2.0, +detune1/1200); // max one semi-tone

    if (firstTime) osc2Octave.buffer = buffer2;
    osc2Octave.playbackRate.value = pitchRate * Math.pow(2.0, octave + detune2/1200); // max one semi-tone

    // Set panning amount for width spreading.

    // pan maximum from -90 -> +90 degrees
    var x = Math.sin(0.5*Math.PI * width);
    var z = -Math.cos(0.5*Math.PI * width);
    panner1.panningModel = webkitAudioPannerNode.EQUALPOWER;
    panner1.setPosition(-x, 0, z);

    panner2.panningModel = webkitAudioPannerNode.EQUALPOWER;
    panner2.setPosition(x, 0, z);

    // Amplitude envelope
    ampEnvelope.gain.cancelScheduledValues(0);

    if (!this.isMonophonic)
        ampEnvelope.gain.setValueAtTime(0.0, time);
    else {
        // ampEnvelope.gain.setValueAtTime(ampEnvelope.gain.value, time); // !! not correct
    }

    // Amplitude attack
    var ampAttackTime = time + ampAttack;

    // Amplitude decay
    ampEnvelope.gain.setTargetValueAtTime(1, time, ampAttack);
    ampEnvelope.gain.setTargetValueAtTime(0, ampAttackTime, ampDecay);

    // Filter
    this.setFilterValues();

    // Set note volume.
    noteVolume.gain.value = 0.1 * volume*volume; // use x^2 volume curve for now

    // Trigger note if polyphonic, otherwise oscillators are running all the time for monophonic.
    if (!this.isMonophonic) {
        var ampDecayAdjust = 8*ampDecay; // time-constant adjusting...
        if (ampDecayAdjust < 0.100) ampDecayAdjust = 0.100;
        if (ampDecayAdjust > 4) ampDecayAdjust = 4;
        var offTime = ampAttackTime + ampDecayAdjust;

        osc1.noteOn(time);
        osc2.noteOn(time);
        osc1.noteOff(offTime);
        osc2.noteOff(offTime);

        osc1Octave.noteOn(time);
        osc2Octave.noteOn(time);
        osc1Octave.noteOff(offTime);
        osc2Octave.noteOff(offTime);
    } else {
        firstTime = false;
    }
}

function setTempo(x) {
    tempo = x;
    bpmDelay.setTempo(tempo);
}


function loadImpulseResponse(url, convolver) {
    // Load impulse response asynchronously

    var request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";

    request.onload = function() {
        convolver.buffer = context.createBuffer(request.response, false);
        isImpulseResponseLoaded = true;
    }
    request.onerror = function() {
        alert("error loading reverb");
    }

    request.send();
}

function StaticAudioRouting() {
    // Create dynamics compressor to sweeten the overall mix.
    var compressor = context.createDynamicsCompressor();
    compressor.connect(context.destination);

    var convolver = context.createConvolver();
    // loadImpulseResponse('impulse-responses/matrix-reverb6.wav', convolver);
    // loadImpulseResponse('impulse-responses/spatialized4.wav', convolver);

    var convolverDry = context.createGainNode();
    var convolverWet = context.createGainNode();

    convolverDry.connect(compressor);
    convolverWet.connect(convolver);
    convolver.connect(compressor);

    // BPM delay through delayWaveShaper feedback loop
    bpmDelay = new BpmDelay(context);

    var delayFeedback = context.createGainNode();
    var delayDry = context.createGainNode();
    var delayWet = context.createGainNode();

    delayFeedback.gain.value = 0.5;
    delayDry.gain.value = 0.5;
    delayWet.gain.value = 0.5;

    delayDry.connect(compressor);
    bpmDelay.delay.connect(delayWet);
    delayWet.connect(compressor);

    bpmDelay.delay.connect(delayFeedback);
    delayWaveShaper = new WaveShaper(context);

    delayFeedback.connect(delayWaveShaper.input);
    delayWaveShaper.output.connect(bpmDelay.delay);

    grungeWaveShaper = new WaveShaper(context);

    // Connect to delay dry/wet
    grungeWaveShaper.output.connect(delayDry);
    grungeWaveShaper.output.connect(bpmDelay.delay);

    // Connect to reverb dry/wet
    grungeWaveShaper.output.connect(convolverDry);
    grungeWaveShaper.output.connect(convolverWet);

    var subsonicFilter = context.createBiquadFilter();

    subsonicFilter.type = 1; // hipass
    subsonicFilter.frequency.value = 10;

    subsonicFilter.connect(grungeWaveShaper.input);

    this.compressor = compressor;
    this.convolver = convolver;
    this.convolverDry = convolverDry;
    this.convolverWet = convolverWet;
    this.bpmDelay = bpmDelay;
    this.delayFeedback = delayFeedback;
    this.delayDry = delayDry;
    this.delayWet = delayWet;
    this.delayWaveShaper = delayWaveShaper;
    this.grungeWaveShaper = grungeWaveShaper;
    this.subsonicFilter = subsonicFilter;

    this.setReverbDryWet(0.2);
}

StaticAudioRouting.prototype.setDelayDryWet = function(x) {
    // Equal-power cross-fade dry -> wet
    var gain1 = 0.5 * (1.0 + Math.cos(x * Math.PI));
    var gain2 = 0.5 * (1.0 + Math.cos((1.0-x) * Math.PI));
    this.delayDry.gain.value = gain1;
    this.delayWet.gain.value = gain2;
}

StaticAudioRouting.prototype.setReverbDryWet = function(x) {
    // Equal-power cross-fade dry -> wet
    var gain1 = 0.5 * (1.0 + Math.cos(x * Math.PI));
    var gain2 = 0.5 * (1.0 + Math.cos((1.0-x) * Math.PI));
    this.convolverDry.gain.value = gain1;
    this.convolverWet.gain.value = gain2;
}

StaticAudioRouting.prototype.setDelayFeedback = function(x) {
    this.delayFeedback.gain.value = x;
}

StaticAudioRouting.prototype.setDelayGrunge = function(driveDb) {
    this.delayWaveShaper.setDrive(Math.pow(10, 0.05*driveDb));
}

StaticAudioRouting.prototype.setMainGrunge = function(driveDb) {
    this.grungeWaveShaper.setDrive(Math.pow(10, 0.05*driveDb));
}

function init() {
    context = new webkitAudioContext();
    staticAudioRouting = new StaticAudioRouting();
    monophonicNote = new Note(staticAudioRouting, true);

    loadWaveTables();

    document.addEventListener('keydown', onDocumentKeyDown, false);
    document.addEventListener('keyup', onDocumentKeyUp, false);

    sequence = new Sequence();

    addUI();
}

function setWaveTable1(name) {
    waveTable = loader.getTable(name);

    // For now, set both wavetables to the same value.
    waveTable2 = loader.getTable(name);
}

function setWaveTable2(name) {
    waveTable2 = loader.getTable(name);
}


function addUI() {
    var controls = document.getElementById("controls");
    views = new Array();

    var j = 0;
    views[j++] = new KnobView("cutoff", cutoff, 0.0, 1.0, UNITS.generic, 1, false, function(value) { cutoff = value; } );
    views[j++] = new KnobView("resonance", resonance, 0, 40 /*20*/, UNITS.decibels, 1, false, function(value) { resonance = value; } );
    views[j++] = new KnobView("envAmount", envAmount, 0, 1, UNITS.generic, 2, false, function(value) { envAmount = value; } );
    views[j++] = new KnobView("filterAttack", filterAttack, 0.004, 0.200, UNITS.seconds, 3, false, function(value) { filterAttack = value; } );
    views[j++] = new KnobView("filterDecay", filterDecay, 0.004, 0.300, UNITS.seconds, 3, false, function(value) { filterDecay = value; } );
    views[j++] = new KnobView("ampAttack", ampAttack, 0.005, 0.300, UNITS.seconds, 3, true, function(value) { ampAttack = value; } );
    views[j++] = new KnobView("ampDecay", ampDecay, 0.001, 5.0, UNITS.seconds, 3, true, function(value) { ampDecay = value; } );
    views[j++] = new KnobView("width", width, 0.0, 1.0, UNITS.generic, 1, false, function(value) { width = value; } );
    views[j++] = new KnobView("detune1", detune1, -50, 50, UNITS.cents, 1, false, function(value) { detune1 = value; } );
    views[j++] = new KnobView("detune2", detune2, -50, 50, UNITS.cents, 1, false, function(value) { detune2 = value; } );
    views[j++] = new KnobView("osc2 octave", octave, 0, 4, UNITS.indexed, 0, false, function(value) { octave = value; } );
    views[j++] = new KnobView("tempo", tempo, 50.0, 240.0, UNITS.bpm, 1, false, function(value) { setTempo(value); } );
    views[j++] = new KnobView("subsonic cutoff", 10, 5, 2000, UNITS.hertz, 0, true, function(value) { subsonicFilter.frequency.value = value; } );
    views[j++] = new KnobView("reverb dry/wet", 20, 0, 100, UNITS.percent, 1, false, function(value) { staticAudioRouting.setReverbDryWet(0.01 * value); } );
    views[j++] = new KnobView("delay dry/wet", 50, 0, 100, UNITS.percent, 1, false, function(value) { staticAudioRouting.setDelayDryWet(0.01 * value); } );
    views[j++] = new KnobView("delay feedback", 50, 0, 100, UNITS.percent, 1, false, function(value) { staticAudioRouting.setDelayFeedback(0.01 * value); } );
    views[j++] = new KnobView("delay grunge", 0, -10, 30, UNITS.decibels, 1, false, function(value) { staticAudioRouting.setDelayGrunge(value); } );
    views[j++] = new KnobView("main grunge", 0, -15, 50, UNITS.decibels, 1, false, function(value) { staticAudioRouting.setMainGrunge(value); } );
    views[j++] = new KnobView("volume", volume, 0.0, 1.0, UNITS.generic, 1, false, function(value) { volume = value; } );

    // installViews(views, controls);

    sequenceView = new SequenceView(sequence, "sequenceView");

    bpmDelay.setDelayValue("quarter note");

    var bpmDelayMenu = document.getElementById("bpmDelayMenu");
    var menuText = 'Delay: <select onchange="bpmDelay.setDelayValue(this.value);">'
        menuText += '<option>32nd note</option>'
        menuText += '<option>16th note triplet</option>'
        menuText += '<option>dotted 32nd note</option>'
        menuText += '<option>16th note</option>'
        menuText += '<option>8th note triplet</option>'
        menuText += '<option>dotted 16th note</option>'
        menuText += '<option>8th note</option>'
        menuText += '<option>quarter note triplet</option>'
        menuText += '<option>dotted eighth note</option>'
        menuText += '<option selected>quarter note</option>'
        menuText += '</select>';
    bpmDelayMenu.innerHTML = menuText;

    loader.makeWavePopup("wavePopup1");
    // loader.makeWavePopup("wavePopup2");
}

function start() {
    // first, get rid of loading animation
    var loading = document.getElementById("loading");
    $(loading).hide();

    // startTime = context.currentTime + 0.160;

    waveTable = loader.getTable(defaultWaveTableName);
    waveTable2 = loader.getTable(defaultWaveTableName);
    sequence.schedule();
}

/* **********************************************
     Begin application.js
********************************************** */



$(document).ready(function(e){
	// I don't know what I'm doing. Obviously.
try{Typekit.load();}catch(e){}

	var playing = false;
	var sliderFix = 100;
	// play = true;
	// Sliders are actually horizontal because you can't style the vertical ones
	// Plus they are being difficult about going top to bottom. So, 100 minus the
	// Value gives us the correct value if the orientation was correct.

	$("#module-range-volume-master").on("change", function() {
		var moduleVolume = sliderFix - this.value;
		volume = (moduleVolume/50); // doubles max possible volumeOneTwoThreeFourFive
		$("#module-range-volume-output").html(moduleVolume);
	});

	$("#module-range-effect-envelope").on("change", function() {
		var moduleEnvAmount = sliderFix - this.value;
		envAmount = (moduleEnvAmount/100);
		$("#module-range-effect-envelope-output").html(moduleEnvAmount);
	});

	$("#module-range-effect-resonance").on("change", function() {
		var moduleResonance = sliderFix - this.value;
		resonance = (moduleResonance * 0.4);
		$("#module-range-effect-resonance-output").html(moduleResonance);
	});

	$("#module-range-effect-cutoff").on("change", function() {
		var moduleCutoff = sliderFix - this.value;
		cutoff = (moduleCutoff/100);
		$("#module-range-effect-cutoff-output").html(moduleCutoff);
	});

	$("#module-range-effect-delay-wd").on("change", function() {
		var moduleDelayWD = sliderFix - this.value;
		cutoff = (moduleDelayWD/100);
		$("#module-range-effect-delay-wd-output").html(moduleDelayWD);
	});

	$("#module-range-osc-detune").on("change", function() {
		var moduleDetune = sliderFix - this.value;
		cutoff = (moduleDetune/100);
		$("#module-range-osc-detune-output").html(moduleDetune);
	});

	$("#module-range-osc-width").on("change", function() {
		var moduleWidth = sliderFix - this.value;
		cutoff = (moduleWidth/100);
		$("#module-range-osc-width-output").html(moduleWidth);
	});

	$("#controls-tempo").on("change", function() {
		var controlTempo = this.value;
		console.log(controlTempo);
		if(controlTempo >= 240) {
			this.value = 240;

		} else if(controlTempo <= 20) {
			controlTempo = 20;
		}
		tempo = controlTempo;
	});


	$("#controls-play").onpress(function() {
		var controlButton = $("#controls-play");
		if(playing == true) {
			startTime = undefined;
			playing = false;
			controlButton.html("Play");
		} else if(playing == false) {
			startTime = 0; // There's a problem here, because of normalising
			// the time somewhere, it doesn't start in the same spot every time.
			playing = true;
			controlButton.html("Stop");
		}

	});

	$("#module-button-osc-poly").onpress(function() {
		polyButton = $("#module-button-osc-poly");
		playMonophonic = !playMonophonic;
		if(playMonophonic) {
			polyButton.html("On");
		} else {
			polyButton.html("Off");
		}
	});

        Flickable('.module-flick', {
            width: 60,
            enableMouseEvents: true,
            callback: function(n) {
                if(n === 0) {
                	setWaveTable1("01_Saw");
                } else if(n === 1) {
                	setWaveTable1("02_Triangle");
                } else if(n === 2) {
                	setWaveTable1("03_Square");
                } else if(n === 3) {
                	setWaveTable1("04_Noise");
                } else if(n === 4) {
                	setWaveTable1("05_Pulse"); // Temp, for some reason changing file names messes with the sounds.
                }
            }
        });

	$(".module .col-header").onpress(function() {
		$(".module").toggleClass("module--closed");
		$(this).parents(".module").toggleClass("module--open").removeClass("module--closed");
	});

	$(".m-play-button").onpress(function(){
		$(this).toggleClass("module--hold")
	});
});